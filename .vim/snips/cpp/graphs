snippet graphal "graph adjecency list"
class graphal
{
  public:
    int n;
    //${1:0} 1->bidirectional, 2->reverse edges
    vector<vi> ed`!p
if t[1]=="2":
  snip.rv= ", rd;"
else:
  snip.rv=";"
`
    graphal(const int &n):n(n),ed(n)`!p
if t[1]=="2":
  snip.rv= ",rd(n)"
else:
  snip.rv=""
`{}
    void add(int a, int b){ ed[a].push_back(b);`!p
if t[1]=="1":
  snip.rv= "ed[b].push_back(a);"
elif t[1]=="2":
  snip.rv= "rd[b].push_back(a);"
else:
  snip.rv=""
` }
    void load(int m){ for(int i=0;i<m;i++){int a=gi(),b=gi();add(a-1,b-1);}}
};
endsnippet

snippet graphwal "weighted adjeceny list graph"
class graphwal
{
  public:
    int n;
    //${1:0} 1->bidirectional, 2->reverse edges
    typedef vector<pair<int,${2:int}>> vpi;
    vector<vpi> ed`!p
if t[1]=="2":
  snip.rv= ",rd;"
else:
  snip.rv=";"
`
    graphwal(int n):n(n),ed(n)`!p
if t[1]=="2":
  snip.rv= ",rd(n)"
else:
  snip.rv=""
`{}
    void add(int a, int b, $2 w){ed[a].pb(mp(b,w));`!p
if t[1]=="1":
  snip.rv= "ed[b].pb(mp(a,w));"
elif t[1]=="2":
  snip.rv= "rd[b].pb(mp(a,w));"
else:
  snip.rv=""
`}
    void load(int m){ for(int i=0;i<m;i++){int a=gi(),b=gi();ll w=gll();add(a-1,b-1,w);}}
};
endsnippet

snippet dfs "dfs on graphal or wal"
void dfs(int v=0, int pa=-1, int d=0){
  bool leaf=true;
  for(auto i:ed[v])
    if(i!=pa){
      leaf=false;
      dfs(i,v,d+1);
    }
  /* if(leaf); */
}
endsnippet

snippet diameter "get the diameter of a tree"
int diameter(int &d, int ix=0, int par=-1){
  //${1:0} 0->all nodes 1->selected nodes
  int mx=`!p
if t[1]=="1":
  snip.rv="-1"
else:
  snip.rv="0"
`,mx2=-1,cur;`!p
if t[1]=="1":
  snip.rv="\n  if(selected[ix])mx=0;"
`
  for(auto i:ed[ix])
  if(i!=par){
    cur=diameter(d,i,ix);
    if(cur>mx){mx2=mx;mx=cur;}else if(cur>mx2)mx2=cur;
  }
  if(mx2!=-1)d=max(d,mx+mx2);
`!p
if t[1]=="1":
  snip.rv="  if(selected[ix] || mx>0)mx++;"
else:
  snip.rv="  mx++;"
`
  return mx;
}
endsnippet

snippet disjoint "disjoint sets"
class disjoint{
  public:
  vi p;
  disjoint(int n):p(n,-1){}
  int find(int ix){return p[ix]<0?ix:p[ix]=find(p[ix]);}
  bool join(int a, int b){
    if((a=find(a))==(b=find(b)))return false;
    if(p[a]<p[b])swap(a,b);
    p[a]+=p[b];
    p[b]=a;
    return true;
  }
};
endsnippet

snippet toposort "topological sorting"
class toposort{
  public:
  vi ts;
  toposort(graphal &g){
    int n=g.n, ix, nx, qb=0,qe=0;
    vi inc(n,0), q(n+1,0);
    ts.clear();

    for(int i=0;i<n;i++) for(auto j:g.ed[i]){ inc[j]++; }

    for(int i=0;i<n;i++)if(inc[i]==0)q[qe++]=i;
    while(qb<qe){
      ix=q[qb++]; ts.pb(ix);
      for(int i=0;i<g.ed[ix].size();i++){
        nx=g.ed[ix][i];
        inc[nx]--;
        if(inc[nx]==0)q[qe++]=nx;
      }
    }
  }
};
endsnippet

snippet maxbpm "maximum bipartite matching"
template <typename T>
class maxbpm {
  int nl,nr;
  vi pr, nx;
  vector<bool> seen;
  const T &adj;
  public:
  maxbpm(int nl, int nr, const T &adj):
    nl(nl),nr(nr),adj(adj),pr(nr,-1),nx(nl,-1),seen(nl){}

  bool dfs(int u){
    if(u==-1) return true;
    if(seen[u]) return false;
    seen[u]=true;
    for(int v=0;v<nr;v++){
      if(adj[u][v] && dfs(pr[v])){
        pr[v]=u;
        nx[u]=v;
        return true;
      }
    }
    return false;
  }

  int calc(){
    int mx=0;
    for(int u=0;u<nl;u++){
      memset(seen,0,sizeof(bool)*nl);
      if(dfs(u)) mx++;
    }
    return mx;
  }
};
endsnippet

snippet lca "least common ancestor"
class lca {
  const graphal &g;
  static const int L=21;
  const int n;
  int timer;
  vector<vi> up;
  vi tin, tout, h;
  public:
    lca(const graphal &g, const int &n):
      g(g),n(n),timer(0),tin(n,0),tout(n,0),h(n,0),
      up(n,vi(L,0)){ }
    void dfs(int v=0, int p=-1){
      int x;
      tin[v]=timer++;
      up[v][0]=p;
      for(int i=1;i<L;i++){
        x=up[v][i-1];
        if(x==-1)up[v][i]=-1;
        else up[v][i]=up[x][i-1];
      }
      for(auto i:g.ed[v])
      if(i!=p){
        h[i]=h[v]+1;
        dfs(i,v);
      }
      tout[v]=timer++;
    }
    bool isa(int a, int b){ return ((a==-1) || (tin[a]<=tin[b] && tout[a]>=tout[b]));}
    int getlca(int a, int b){
      if(isa(a,b))return a;
      if(isa(b,a))return b;
      for(int i=L-1;i>=0;i--){
        if(!isa(up[a][i],b))a=up[a][i];
      }
      return up[a][0]==-1?a:up[a][0];
    }
    int getdist(int a, int b){ return h[a]+h[b]-2*h[getlca(a,b)]; }
    int go(int v, int len){
      for(auto i=L-1;i>=0;i--)if(up[v][i]!=-1 && (len&(1<<i))){ v=up[v][i];}
      return v;
    }
};
endsnippet

snippet dijkstra "Dijkstra's shortest path algorithm"
class dijkstra{
  public:
  typedef ${1:int} dt;
  typedef pair<dt,int> pt;
  int n, done;
  const graphwal &g;
  vector<dt> d;
  vi pr;
  vector<bool> v;
  const static dt MAXV=${2:INT_MAX};
  priority_queue<pt,vector<pt>,${3:greater<pt>}> h;
  dijkstra(const graphwal &g):
  n(g.n),done(-1),g(g),
  d(n),pr(n),v(n){ }
  void findall(int sr=0){
    pt ret;
    fill(v.begin(),v.end(),false);
    fill(pr.begin(),pr.end(),-1);
    fill(d.begin(),d.end(),MAXV);
    d[sr]=0;
    for(auto i:g.ed[sr]){
      d[i.fi]=i.se;
      h.push(pt(i.se,i.fi));
    }
    while(!h.empty()){
      ret=h.top();
      h.pop();
      if(v[ret.se])continue;
      v[ret.se]=true;
      for(auto i:g.ed[ret.se]){
        if(!v[i.fi] && d[i.fi]-i.se > ret.fi){
          d[i.fi]=ret.fi+i.se;
          pr[i.fi]=ret.se;
          h.push(pt(d[i.fi],i.fi));
        }
      }
    }
    done=sr;
  }
  dt find(int tr, int sr=0){
    if(done!=sr) findall(sr);
    if(d[tr]==MAXV)return -1;
    return d[tr];
  }
};
endsnippet

snippet prims "prim's algorithm for mst"
class prims{
  public:
  typedef ll dt;
  typedef pair<dt,int> pt;
  int n;
  const graphwal &g;
  vector<dt> d;
  vi pr;
  vector<bool> v;
  const static dt MAXV=LLONG_MAX;
  priority_queue<pt,vector<pt>,greater<pt>> h;
  prims(const graphwal &g):
    n(g.n),g(g),d(n),pr(n),v(n){}
  dt calc(int sr=0){
    pt ret;
    dt mst=0;
    int nmst=0;
    fill(v.begin(),v.end(),false);
    fill(pr.begin(),pr.end(),-1);
    fill(d.begin(),d.end(),MAXV);
    d[sr]=0;
    h.push(pt(0,sr));
    while(!h.empty()){
      ret=h.top();
      h.pop();
      if(v[ret.se])continue;
      v[ret.se]=true;
      mst+=ret.fi;
      nmst++;
      for(auto i:g.ed[ret.se]){
        if(!v[i.fi] && d[i.fi] > i.se){
          d[i.fi]=i.se;
          pr[i.fi]=ret.se;
          h.push(pt(d[i.fi],i.fi));
        }
      }
    }
    if(nmst!=n)return -1;
    return mst;
  }
  bool inmst(int a, int b){
    return (pr[a]==b || pr[b]==a);
  }
};
endsnippet

snippet hungarian "hungarian algo"
class hungarian{
  static const int N=${1:105};
  static const ${2:int} INF=${3:INT_MAX};
  typedef ${4:int} dt;
  typedef vector<dt> cdt;
  typedef vector<cdt> ct;
  public:
  int nx,ny,mx,xy[N],yx[N],prev[N],slackx[N];
  dt lx[N],ly[N],slack[N];
  bool s[N],t[N];
  const ct &cost;
  hungarian(const int &nx,const int &ny,const ct &cost):nx(nx),ny(ny),cost(cost){}
  void init()
  {
    memset(lx, 0, sizeof(lx));
    memset(ly, 0, sizeof(ly));
    for (int x=0;x<nx; x++)
      for (int y=0;y<ny; y++)
        lx[x] = max(lx[x], cost[x][y]);
  }
  void update() {
    int x, y; //init delta as infinity
    dt delta=INF;
    for (y=0;y<ny;y++) //calculate delta using slack
      if (!t[y]) delta = min(delta, slack[y]);
    for (x=0;x<nx;x++) //update X labels
      if (s[x]) lx[x] -= delta;
    for (y=0;y<ny;y++) //update Y labels
      if (t[y]) ly[y] += delta;
    for (y=0;y<ny;y++) //update slack array
      if (!t[y]) slack[y] -= delta;
  }
  void add(int x, int prevx){
    //x - current vertex,prevx - vertex from X before x in the alternating path,
    //so we add edges (prevx, xy[x]), (xy[x], x)
    s[x] = true; //add x to S
    prev[x] = prevx; //we need this when augmenting
    for (int y=0;y<ny;y++) //update slacks, because we add new vertex to S
      if (lx[x] + ly[y] - cost[x][y] < slack[y]){
        slack[y] = lx[x] + ly[y] - cost[x][y];
        slackx[y] = x;
      }
  }

  void augment(){ //main function of the algorithm
    if (mx == min(nx,ny)) return; //check wether matching is already perfect
    int x, y, root; //just counters and root vertex
    int q[N], wr = 0, rd = 0; //q - queue for bfs, wr,rd - write and read
    //pos in queue
    memset(s, false, sizeof(s)); //init set S
    memset(t, false, sizeof(t)); //init set T
    memset(prev, -1, sizeof(prev)); //init set prev - for the alternating tree
    for (x=0;x<nx; x++) //finding root of the tree
      if (xy[x] == -1){
        q[wr++] = root = x;
        prev[x] = -2;
        s[x] = true;
        break;
      }
    for (y=0;y<ny;y++){ //initializing slack array
      slack[y] = lx[root] + ly[y] - cost[root][y];
      slackx[y] = root;
    }
    //second part of augment() function
    while (true) //main cycle
    {
      while (rd < wr) //building tree with bfs cycle
      {
        x = q[rd++]; //current vertex from X part
        for (y=0;y<ny;y++) //iterate through all edges in equality graph
          if (cost[x][y] == lx[x] + ly[y] && !t[y])
          {
            if (yx[y] == -1) break; //an exposed vertex in Y found, so augmenting path exists!
            t[y] = true; //else just add y to T,
            q[wr++] = yx[y]; //add vertex yx[y], which is matched with y, to the queue
            add(yx[y], x); //add edges (x,y) and (y,yx[y]) to the tree
          }
        if (y<ny) break; //augmenting path found!
      }
      if (y<ny) break; //augmenting path found!

      update(); //augmenting path not found, so improve labeling
      wr = rd = 0;
      for (y=0;y<ny;y++)
        //in this cycle we add edges that were added to the equality graph as a
        //result of improving the labeling, we add edge (slackx[y], y) to the tree if
        //and only if !T[y] && slack[y] == 0, also with this edge we add another one
        //(y, yx[y]) or augment the matching, if y was exposed
        if (!t[y] && slack[y] == 0)
        {
          if (yx[y] == -1) //exposed vertex in Y found - augmenting path exists!
          {
            x = slackx[y];
            break;
          }
          else
          {
            t[y] = true; //else just add y to T,
            if (!s[yx[y]])
            {
              q[wr++] = yx[y]; //add vertex yx[y], which is matched with y, to the queue
              add(yx[y], slackx[y]); //and add edges (x,y) and (y, yx[y]) to the tree
            }
          }
        }
      if (y<ny) break; //augmenting path found!
    }
    if(y<ny) //we found augmenting path!
    {
      mx++; //increment matching in this cycle we inverse edges along augmenting path
      for (int cx = x, cy = y, ty; cx != -2; cx = prev[cx], cy = ty)
      {
        ty = xy[cx];
        yx[cy] = cx;
        xy[cx] = cy;
      }
      augment(); //recall function, go to step 1 of the algorithm
    }
  }//end of augment() function
  dt doit()
  {
   dt ret = 0; //weight of the optimal matching
   mx = 0; //number of vertices in current matching
   memset(xy, -1, sizeof(xy));
   memset(yx, -1, sizeof(yx));
   init(); //step 0
   augment(); //steps 1-3
   for (int x=0;x<nx;x++) ret += cost[x][xy[x]];
   return ret;
  }
};
endsnippet

snippet tarjan "tarjan algo for scc and bi vertex and bi edge"
class tarjan {
  const graphwal &g;
  vi d,flags,stack;
  int to;
  bool ans;
  public:
  tarjan(const graphwal &g):
    g(g),
    d(g.n,-1),
    flags(g.n+1,-1),
    stack() { }

  int dfs(int v, int prev) {
    int timer = stack.size(), cdrn=0;
    stack.pb(v);
    int res=d[v]=timer;
    bool ap=false;
    for(auto& edge : g.ed[v]){
      int nv = edge.fi, nres;
      if(nv == prev) {continue;}
      cdrn++;
      if(d[nv] < 0) { //not visited
        nres=dfs(nv,v);
        if(nres>=timer)ap=true;
        res = min(res,nres);
      }
      else { res = min(res, d[nv]); }  //visited
    }
    if(ap==true || (prev==g.n && cdrn>1)){} // articulation point

    //edge bi-connected component or strongly connected compoenent. root is selected by default
    //all the items from timer till the end of the stack belongs to one biconnected component.
    //all the edges among those items only needs to be selected.
    //(There could be outgoing edges to other components which needs to be ignored.)
    if(res == timer){
      if(find(stack.begin() + timer, stack.end(), to) != stack.end()) {
        for(size_t i=timer;i<stack.size();i++){flags[stack[i]] = v;}
        flags[prev]=v; //The incoming edge from parent is selected.
        for(size_t i=timer;i<stack.size();i++) {
          for(auto& edge : g.ed[stack[i]]) {
            if(flags[edge.fi]==v && edge.se==1){ans = true;}
          }
        }
        flags[prev] = -1;
        to = prev;
      }
      for(size_t i=timer;i<stack.size();i++){d[stack[i]]=g.n;}
      stack.resize(timer);
    }
    return res;
  }
  //find all components from a to b
  bool go(int a, int b) {
    to=b;
    ans=false;
    dfs(a,g.n);
    return ans;
  }
};
endsnippet

snippet floyd "all pair shortest path"
for(int k=0;k<n;k++)
for(int i=0;i<n;i++)
for(int j=0;j<n;j++){if(d[i][j]>d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];}
endsnippet

snippet bfsgraph "bfs on a graph"
void bfs(int s=0){
  int qb=0, qe=0, ix;
  vector<int> q(n);
  vector<${1:int}> ${2:d}(n);
  fill($2.begin(),$2.end(),${3:INT_MAX});
  $2[s]=0;
  q[qe++]=s;
  while(qb<qe){
    ix=q[qb++];
    for(auto i:ed[ix])
      if($2[i]>$2[ix]+1){
        $2[i]=$2[ix]+1;
        q[qe++]=i;
      }
  }
}
endsnippet
