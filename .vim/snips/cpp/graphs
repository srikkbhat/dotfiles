snippet graphal "graph adjecency list"
class graphal
{
  public:
    int n;
    //${1:0} 1->bidirectional, 2->reverse edges
    vector<vi> ed`!p
if t[1]=="2":
  snip.rv= ", rd;"
else:
  snip.rv=";"
`
    graphal(const int &n):n(n),ed(n)`!p
if t[1]=="2":
  snip.rv= ",rd(n)"
else:
  snip.rv=""
`{}
    void add(int a, int b){ ed[a].push_back(b);`!p
if t[1]=="1":
  snip.rv= "ed[b].push_back(a);"
elif t[1]=="2":
  snip.rv= "rd[b].push_back(a);"
else:
  snip.rv=""
` }
    void load(int m){ for(int i=0;i<m;i++){int a=getint(),b=getint();add(a-1,b-1);}}
};
endsnippet

snippet graphwal "weighted adjeceny list graph"
class graphwal
{
  public:
    int n;
    //${1:0} 1->bidirectional, 2->reverse edges
    typedef vector<pair<int,${2:int}>> vpi;
    vector<vpi> ed`!p
if t[1]=="2":
  snip.rv= ",rd;"
else:
  snip.rv=";"
`
    graphwal(int n):n(n),ed(n)`!p
if t[1]=="2":
  snip.rv= ",rd(n)"
else:
  snip.rv=""
`{}
    void add(int a, int b, $2 w){ed[a].pb(mp(b,w));`!p
if t[1]=="1":
  snip.rv= "ed[b].pb(mp(a,w));"
elif t[1]=="2":
  snip.rv= "rd[b].pb(mp(a,w));"
else:
  snip.rv=""
`}
    void load(int m){ for(int i=0;i<m;i++){int a=getint(),b=getint();ll w=getll();add(a-1,b-1,w);}}
};
endsnippet

snippet dfs "dfs on graphal or wal"
void dfs(int v=0, int pa=-1, int d=0){
  bool leaf=true;
  for(auto i:ed[v])
    if(i!=pa){
      leaf=false;
      dfs(i,v,d+1);
    }
  /* if(leaf); */
}
endsnippet

snippet diameter "get the diameter of a tree"
int diameter(int &d, int ix=0, int par=-1){
  //${1:0} 0->all nodes 1->selected nodes
  int mx=`!p
if t[1]=="1":
  snip.rv="-1"
else:
  snip.rv="0"
`,mx2=-1,cur;`!p
if t[1]=="1":
  snip.rv="\n  if(selected[ix])mx=0;"
`
  for(auto i:ed[ix])
  if(i!=par){
    cur=diameter(d,i,ix);
    if(cur>mx){mx2=mx;mx=cur;}else if(cur>mx2)mx2=cur;
  }
  if(mx2!=-1)d=max(d,mx+mx2);
`!p
if t[1]=="1":
  snip.rv="  if(selected[ix] || mx>0)mx++;"
else:
  snip.rv="  mx++;"
`
  return mx;
}
endsnippet

snippet disjoint "disjoint sets"
class disjoint{
  public:
  vi p;
  disjoint(int n):p(n,-1){}
  int find(int ix){return p[ix]<0?ix:p[ix]=find(p[ix]);}
  bool join(int a, int b){
    if((a=find(a))==(b=find(b)))return false;
    if(p[a]<p[b])swap(a,b);
    p[a]+=p[b];
    p[b]=a;
    return true;
  }
};
endsnippet

snippet toposort "topological sorting"
class toposort{
  public:
  vi ts;
  toposort(graphal &g){
    int n=g.n, ix, nx, qb=0,qe=0;
    vi inc(n,0), q(n+1,0);
    ts.clear();

    for(int i=0;i<n;i++) for(auto j:g.ed[i]){ inc[j]++; }

    for(int i=0;i<n;i++)if(inc[i]==0)q[qe++]=i;
    while(qb<qe){
      ix=q[qb++]; ts.pb(ix);
      for(int i=0;i<g.ed[ix].size();i++){
        nx=g.ed[ix][i];
        inc[nx]--;
        if(inc[nx]==0)q[qe++]=nx;
      }
    }
  }
};
endsnippet

snippet maxbpm "maximum bipartite matching"
template <typename T>
class maxbpm {
  int nl,nr;
  vi pr, nx;
  vector<bool> seen;
  const T &adj;
  public:
  maxbpm(int nl, int nr, const T &adj):
    nl(nl),nr(nr),adj(adj),pr(nr,-1),nx(nl,-1),seen(nl){}

  bool dfs(int u){
    if(u==-1) return true;
    if(seen[u]) return false;
    seen[u]=true;
    for(int v=0;v<nr;v++){
      if(adj[u][v] && dfs(pr[v])){
        pr[v]=u;
        nx[u]=v;
        return true;
      }
    }
    return false;
  }

  int calc(){
    int mx=0;
    for(int u=0;u<nl;u++){
      memset(seen,0,sizeof(bool)*nl);
      if(dfs(u)) mx++;
    }
    return mx;
  }
};
endsnippet

snippet lca "least common ancestor"
class lca {
  const graphal &g;
  static const int L=21;
  const int n;
  int timer;
  vector<vi> up;
  vi tin, tout, h;
  public:
    lca(const graphal &g, const int &n):
      g(g),n(n),timer(0),tin(n,0),tout(n,0),h(n,0),
      up(n,vi(L,0)){ }
    void dfs(int v=0, int p=-1){
      int x;
      tin[v]=timer++;
      up[v][0]=p;
      for(int i=1;i<L;i++){
        x=up[v][i-1];
        if(x==-1)up[v][i]=-1;
        else up[v][i]=up[x][i-1];
      }
      for(auto i:g.ed[v])
      if(i!=p){
        h[i]=h[v]+1;
        dfs(i,v);
      }
      tout[v]=timer++;
    }
    bool isa(int a, int b){ return ((a==-1) || (tin[a]<=tin[b] && tout[a]>=tout[b]));}
    int getlca(int a, int b){
      if(isa(a,b))return a;
      if(isa(b,a))return b;
      for(int i=L-1;i>=0;i--){
        if(!isa(up[a][i],b))a=up[a][i];
      }
      return up[a][0]==-1?a:up[a][0];
    }
    int getdist(int a, int b){ return h[a]+h[b]-2*h[getlca(a,b)]; }
    int go(int v, int len){
      for(auto i=L-1;i>=0;i--)if(up[v][i]!=-1 && (len&(1<<i))){ v=up[v][i];}
      return v;
    }
};
endsnippet

snippet dijkstra "Dijkstra's shortest path algorithm"
class dijkstra{
  public:
  typedef ${1:int} dt;
  typedef pair<dt,int> pt;
  int n, done;
  vi pr;
  vector<dt> d;
  vector<bool> v;
  const graphwal &g;
  const static dt MAXV=${2:INT_MAX};
  priority_queue<pt,vector<pt>,${3:greater<pt>}> h;
  dijkstra(const graphwal &g):
  g(g),n(g.n),done(-1),
  d(n),pr(n),v(n){ }
  void findall(int sr=0){
    pt ret;
    fill(v.begin(),v.end(),false);
    fill(pr.begin(),pr.end(),-1);
    fill(d.begin(),d.end(),MAXV);
    d[sr]=0;
    for(auto i:g.ed[sr]){
      d[i.fi]=i.se;
      h.push(pt(i.se,i.fi));
    }
    while(!h.empty()){
      ret=h.top();
      h.pop();
      if(v[ret.se])continue;
      v[ret.se]=true;
      for(auto i:g.ed[ret.se]){
        if(!v[i.fi] && d[i.fi]-i.se > ret.fi){
          d[i.fi]=ret.fi+i.se;
          pr[i.fi]=ret.se;
          h.push(pt(d[i.fi],i.fi));
        }
      }
    }
    done=sr;
  }
  dt find(int tr, int sr=0){
    if(done!=sr) findall(sr);
    if(d[tr]==MAXV)return -1;
    return d[tr];
  }
};
endsnippet

snippet prims "prim's algorithm for mst"
class prims{
  public:
  typedef ll dt;
  typedef pair<dt,int> pt;
  int n;
  vi pr;
  vector<dt> d;
  vector<bool> v;
  const graphwal &g;
  const static dt MAXV=LLONG_MAX;
  priority_queue<pt,vector<pt>,greater<pt>> h;
  prims(const graphwal &g):
    n(g.n),g(g),d(n),pr(n),v(n){}
  dt calc(int sr=0){
    pt ret;
    dt mst=0;
    int nmst=0;
    fill(v.begin(),v.end(),false);
    fill(pr.begin(),pr.end(),-1);
    fill(d.begin(),d.end(),MAXV);
    d[sr]=0;
    h.push(pt(0,sr));
    while(!h.empty()){
      ret=h.top();
      h.pop();
      if(v[ret.se])continue;
      v[ret.se]=true;
      mst+=ret.fi;
      nmst++;
      for(auto i:g.ed[ret.se]){
        if(!v[i.fi] && d[i.fi] > i.se){
          d[i.fi]=i.se;
          pr[i.fi]=ret.se;
          h.push(pt(d[i.fi],i.fi));
        }
      }
    }
    if(nmst!=n)return -1;
    return mst;
  }
  bool inmst(int a, int b){
    return (pr[a]==b || pr[b]==a);
  }
};
endsnippet
