snippet graphal "graph adjecency list"
class graphal
{
  public:
    int n;
    //1 -> reverse edge, 2->bidirectional
    //${1:0}
    vector <int> * ed;
`!p
if t[1]=="2":
  snip.rv= "    vector <int> * rd;"
else:
  snip.rv=""
`
    graphal(int n){
      this->n=n;
      ed = new vector<int>[n];
`!p
if t[1]=="2":
  snip.rv= "      rd = new vector<int>[n];"
else:
  snip.rv=""
`
    }
    ~graphal(){
      delete[] ed;
`!p
if t[1]=="2":
  snip.rv= "      delete[] rd;"
else:
  snip.rv=""
`
    }
    void add(int a, int b){
      ed[a].push_back(b);
`!p
if t[1]=="1":
  snip.rv= "      ed[b].push_back(a);"
else:
  snip.rv=""
`
`!p
if t[1]=="2":
  snip.rv= "      rd[b].push_back(a);"
else:
  snip.rv=""
`
    }
};
endsnippet

snippet graphwal "weighted adjeceny list graph"
class graphwal
{
  public:
    int n;
    //1,3 -> reverse edge, 2,3->bidirectional
    int rev;
    vector < vector <pair<int,${1:int}> > >  ed;
    vector < vector <pair<int,$1> > > red;
    graphwal(){
      n=0;
      rev=0;
    }
    graphwal(int n){
      this.n=n;
      rev=0;
      ed.resize(n);
    }
    graphwal(int n, int rev){
      this.n = n;
      this.rev = rev;
      ed.resize(n);
      if(rev&1) red.resize(n);
    }
    ~graphwal(){
      ed.clear();
      if(rev&1) red.clear();
    }
    void addEdge(int a, int b, $1 w){
      ed[a].pb(mp(b,w));
      if(rev>1)ed[b].pb(mp(a,w));
      if(rev&1)red[b].pb(mp(a,w));
    }
};
endsnippet

snippet toposort "topological sorting"
class toposort{
  public:
  vector<int> ts;
  toposort(graphal &g){
    int n, ix, nx, *inc, *q, qb,qe;
    n=g.n;
    inc=new int[n]();
    q=new int[n+1]();
    qb=qe=0;
    ts.clear();

    for(int i=0;i<n;i++)
      for(int j=0;j<g.ed[i].size();j++){
        inc[g.ed[i][j]]++;
      }

    for(int i=0;i<n;i++)if(inc[i]==0)q[qe++]=i;
    while(qb<qe){
      ix=q[qb++];
      ts.pb(ix);
      for(int i=0;i<g.ed[ix].size();i++){
        nx=g.ed[ix][i];
        inc[nx]--;
        if(inc[nx]==0)q[qe++]=nx;
      }
    }
  }
  ~toposort(){
    delete[] q;
    delete[] inc;
  }
};

endsnippet

snippet maxbpm "maximum bipartite matching"
template <typename T>
class maxbpm {
  int nl,nr;
  int *pr, *nx;
  bool *seen;
  const T *adj;
  public:
  maxbpm(int nl, int nr, const T &adj) {
    this->nl=nl;
    this->nr=nr;
    this->adj=&adj;
    nx=new int[nl];
    pr=new int[nr];
    seen=new bool[nl];
  }

  bool dfs(int u){
    if(u==-1) return true;
    if(seen[u]) return false;
    seen[u]=true;
    for(int v=0;v<nr;v++){
      if(adj[u][v] && dfs(pr[v])){
        pr[v]=u;
        nx[u]=v;
        return true;
      }
    }
    return false;
  }

  int calc(){
    int mx=0;
    memset(pr,-1,sizeof(int)*nr);
    memset(nx,-1,sizeof(int)*nl);
    for(int u=0;u<nl;u++){
      memset(seen,0,sizeof(int)*nl);
      if(dfs(u)) mx++;
    }
    return mx;
  }
};
endsnippet

snippet lca "least common ancestor"
class lca {
  const graphal *g;
  static const int L=21;
  int n, timer;
  int *tin, *tout, **up, *h;
  public:
    lca(const graphal &g, const int &n){
      this->g=&g;
      this->n=n;
      tin=new int[n]();
      tout=new int[n]();
      h=new int[n]();
      up=new int*[n];
      for(int i=0;i<n;i++)up[i]=new int[L]();
      timer=0;
    }
    ~lca(){
      delete[] tin;
      delete[] tout;
      delete[] h;
      for(int i=0;i<n;i++)delete[] up[i];
      delete[] up;
    }
    void dfs(int v=0, int p=0){
      tin[v]=timer++;
      up[v][0]=p;
      for(int i=1;i<L;i++)up[v][i]=up[up[v][i-1]][i-1];
      for(int i=0;i<g->ed[v].size();i++){
        int to=g->ed[v][i];
        if(to==p)continue;
        h[to]=h[v]+1;
        dfs(to,v);
      }
      tout[v]=timer++;
    }
    bool isa(int a, int b){ return (tin[a]<=tin[b] && tout[a]>=tout[b]); }
    int getlca(int a, int b){
      if(isa(a,b))return a;
      if(isa(b,a))return b;
      for(int i=L-1;i>=0;i--){
        if(!isa(up[a][i],b))a=up[a][i];
      }
      return up[a][0];
    }
    int get_dist(int a, int b){ return h[a]+h[b]-2*h[getlca(a,b)]; }
};
endsnippet
