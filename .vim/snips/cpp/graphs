snippet graphal "graph adjecency list"
class graphal
{
  public:
    int n;
    //${1:0} 1->bidirectional, 2->reverse edges
    vector <int> *ed`!p
if t[1]=="2":
  snip.rv= ", *rd;"
else:
  snip.rv=";"
`
    graphal(const int &n){
      this->n=n;
      ed = new vector<int>[n]; `!p
if t[1]=="2":
  snip.rv= "\n      rd = new vector<int>[n];"
else:
  snip.rv=""
`
    }
    ~graphal(){ delete[] ed;`!p
if t[1]=="2":
  snip.rv= "delete[] rd;"
else:
  snip.rv=""
` }
    void add(int a, int b){ ed[a].push_back(b);`!p
if t[1]=="1":
  snip.rv= "ed[b].push_back(a);"
elif t[1]=="2":
  snip.rv= "rd[b].push_back(a);"
else:
  snip.rv=""
` }
    void load(int m){
      int x,y;
      for(int i=0;i<m;i++){
        scanf("%d %d",&x,&y);
        add(x-1,y-1);
      } 
    }
};
endsnippet


snippet graphwal "weighted adjeceny list graph"
class graphwal
{
  public:
    int n;
    //${1:0} 1->bidirectional, 2->reverse edges
    typedef vector<pair<int,${2:int}>> vpi;
    vpi *ed`!p
if t[1]=="2":
  snip.rv= ", *rd;"
else:
  snip.rv=";"
`
    graphwal(int n){
      this->n=n;
      ed=new vpi[n];`!p
if t[1]=="2":
  snip.rv= "\n      rd=new vpi[n];"
else:
  snip.rv=""
`
    }
    ~graphwal(){delete[] ed;`!p
if t[1]=="2":
  snip.rv= "delete[] rd;"
else:
  snip.rv=""
`}
    void addEdge(int a, int b, $2 w){ed[a].pb(mp(b,w));`!p
if t[1]=="1":
  snip.rv= "ed[b].pb(mp(a,w));"
elif t[1]=="2":
  snip.rv= "rd[b].pb(mp(a,w));"
else:
  snip.rv=""
`}
    void load(int m){
      int x,y;
      $2 w;
      for(int i=0;i<m;i++){
        scanf("%d %d %d",&x,&y,&w);  
        add(x-1,y-1,w);
      }
    }
};
endsnippet

snippet dfs "dfs on graphal or wal"
void dfs(int ix=0, int par=-1, int d=0){
  bool leaf=true;
  for(auto i:ed[ix])
    if(i!=par){
      leaf=false;
      dfs(i,ix,d+1);
    }
  /* if(leaf); */
}
endsnippet
snippet disjoint "disjoint sets"
class disjoint{
  public:
  int *p;
  disjoint(int n):n(n){
    p = new int[n];
    memset(p,-1,sizeof(int)*n);
  }
  ~disjoint(){delete[] p;}
  find(int ix){return p[ix]<0?ix:p[ix]=find(p[ix]);}
  join(int a, int b){
    if((a=find(a))==(b=find(b)))return;
    if(p[a]<p[b])swap(a,b);
    p[a]+=p[b];
    p[b]=a;
  }
}

endsnippet

snippet toposort "topological sorting"
class toposort{
  public:
  vector<int> ts;
  toposort(graphal &g){
    int n=g.n, ix, nx, *inc, *q, qb=0,qe=0;
    inc=new int[n](); q=new int[n+1](); ts.clear();

    for(int i=0;i<n;i++) for(auto j:g.ed[i]){ inc[j]++; }

    for(int i=0;i<n;i++)if(inc[i]==0)q[qe++]=i;
    while(qb<qe){
      ix=q[qb++]; ts.pb(ix);
      for(int i=0;i<g.ed[ix].size();i++){
        nx=g.ed[ix][i];
        inc[nx]--;
        if(inc[nx]==0)q[qe++]=nx;
      }
    }
    delete[] q; delete[] inc;
  }
};

endsnippet

snippet maxbpm "maximum bipartite matching"
template <typename T>
class maxbpm {
  int nl,nr;
  int *pr, *nx;
  bool *seen;
  const T *adj;
  public:
  maxbpm(int nl, int nr, const T &adj) {
    this->nl=nl;
    this->nr=nr;
    this->adj=&adj;
    nx=new int[nl];
    pr=new int[nr];
    seen=new bool[nl];
  }

  bool dfs(int u){
    if(u==-1) return true;
    if(seen[u]) return false;
    seen[u]=true;
    for(int v=0;v<nr;v++){
      if(adj[u][v] && dfs(pr[v])){
        pr[v]=u;
        nx[u]=v;
        return true;
      }
    }
    return false;
  }

  int calc(){
    int mx=0;
    memset(pr,-1,sizeof(int)*nr);
    memset(nx,-1,sizeof(int)*nl);
    for(int u=0;u<nl;u++){
      memset(seen,0,sizeof(bool)*nl);
      if(dfs(u)) mx++;
    }
    return mx;
  }
};
endsnippet

snippet lca "least common ancestor"
class lca {
  const graphal *g;
  static const int L=21;
  int n, timer;
  int *tin, *tout, **up, *h;
  public:
    lca(const graphal &g, const int &n){
      this->g=&g; this->n=n; timer=0;
      tin=new int[n](); tout=new int[n]();
      h=new int[n](); up=new int*[n];
      for(int i=0;i<n;i++)up[i]=new int[L]();
    }
    ~lca(){
      delete[] tin; delete[] tout; delete[] h;
      for(int i=0;i<n;i++)delete[] up[i];
      delete[] up;
    }
    void dfs(int v=0, int p=0){
      tin[v]=timer++;
      up[v][0]=p;
      for(int i=1;i<L;i++)up[v][i]=up[up[v][i-1]][i-1];
      for(int i=0;i<g->ed[v].size();i++){
        int to=g->ed[v][i];
        if(to==p)continue;
        h[to]=h[v]+1;
        dfs(to,v);
      }
      tout[v]=timer++;
    }
    bool isa(int a, int b){ return (tin[a]<=tin[b] && tout[a]>=tout[b]); }
    int getlca(int a, int b){
      if(isa(a,b))return a;
      if(isa(b,a))return b;
      for(int i=L-1;i>=0;i--){
        if(!isa(up[a][i],b))a=up[a][i];
      }
      return up[a][0];
    }
    int get_dist(int a, int b){ return h[a]+h[b]-2*h[getlca(a,b)]; }
};
endsnippet

snippet dijkstra "Dijkstra's shortest path algorithm"
class dijkstra{
  public:
  typedef ${1:int} dt;
  typedef pair<dt,int> pt;
  int n, *pr, done;
  dt *d;
  bool *v;
  const graphwal *g;
  const static dt MAXV=${2:INT_MAX};
  priority_queue<pt,vector<pt>,${3:greater<pt>}> h;
  dijkstra(const graphwal &g){
    this->g=&g; n=g.n;done=-1;
    d=new dt[n]; pr=new int[n]; v=new bool[n];
  }
  ~dijkstra(){delete[] d;delete[] pr;delete[] v;}
  void findall(int sr=0){
    pt ret;
    memset(v,false,sizeof(bool)*n);
    memset(pr,-1,sizeof(int)*n);
    for(auto i=0;i<n;i++)d[i]=MAXV;
    d[sr]=0;
    for(auto i:g->ed[sr]){
      d[i.fi]=i.se;
      h.push(pt(i.se,i.fi));
    }
    while(!h.empty()){
      ret=h.top();
      h.pop();
      if(v[ret.se])continue;
      v[ret.se]=true;
      for(auto i:g->ed[ret.se]){
        if(!v[i.fi] && d[i.fi]-i.se > ret.fi){
          d[i.fi]=ret.fi+i.se;
          pr[i.fi]=ret.se;
          h.push(pt(d[i.fi],i.fi));
        }
      }
    }
    done=sr;
  }
  dt find(int tr, int sr=0){
    if(done!=sr) findall(sr);
    if(d[tr]==MAXV)return -1;
    return d[tr];
  }
};
endsnippet
