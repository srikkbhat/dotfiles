snippet segmenttree "segment tree range queries"
struct segdiff{
  int val;
  segdiff(){ val=0; }
  segdiff(int val):val(val){}
  void reset() { val=0; }
  void update(const segdiff &u){
    val += u.val;
  }
  void debug() const { printf("diff: %d\n",val); }
};

struct segval{
  int val;
  segval(){val=0;}
  segval(int av){
    set(av);
  }
  void set(int av){
    val=av;
  }
  void apply(const segdiff &u){
    val += u.val;
  }
  int getval(){
    return val;
  }
  void update(const segval &left, const segval &right){
    val = left.val+right.val;
  }
  void debug() {
    printf("val: %d\n", val);
  }
};

struct segtree{
  const int &n; const vector<ll> &a;
  int mxsz;
  vector<segval> val;
  vector<segdiff> diff;
  vector<bool> lz;
  public:
  segtree(const vector<node> &a, const int &n):
    n(n),a(a),mxsz(4*n),val(4*n),diff(4*n),lz(4*n,false){}

  void build(){build(1,0,n-1);}
  void build(int v, int l, int r){
    if(l==r){
      val[v].set(a[l].v);
      return;
    }
    int mid = (l+r)/2, nv=v*2;
    build(nv, l, mid); build(nv+1, mid+1, r);
    val[v].update(val[nv], val[nv+1]);
  }
  void push(int v){
    int nv=v*2;
    if(nv+1<mxsz) {
      diff[nv].update(diff[v]);
      diff[nv+1].update(diff[v]);
      lz[nv]=lz[nv+1]=true;
    }
    val[v].apply(diff[v]);
    diff[v].reset();
    lz[v]=false;
  }
  void updaterange(int ql, int qr, const segdiff &u){updaterange(1,0,n-1,ql,qr,u);}
  void updaterange(int v, int L, int R, int ql, int qr, const segdiff &u){
    if(ql>qr)return;
    if(lz[v])push(v);
    if(ql>R || qr<L)return;
    if(ql<=L && qr>=R){
      diff[v].update(u);
      push(v);
      return;
    }
    int mid = (L+R)/2, nv=v*2;
    updaterange(nv, L, mid, ql,qr,u);
    updaterange(nv+1, mid+1, R, ql,qr,u);
    val[v].update(val[nv], val[nv+1]);
  }
  segval query(int ql, int qr){return query(1,0,n-1,ql,qr);}
  segval query(int v, int L, int R, int ql,int qr){ //ql, qr inclusive
    if(ql>R || qr<L)return segval();
    if(lz[v]) push(v);
    if(ql<=L && qr>=R){
      return val[v];
    }
    int MID = (L+R)/2, nv=v*2;
    segval result;
    result.update(query(nv, L, MID, ql,qr), query(nv+1,MID+1, R, ql,qr));
    return result;
  }
};
endsnippet

snippet fenwicksum "range sum using fenwick"
//fenwick class. index 1 to n for array of size n
template <typename T>
class fenwick {
  int n;vector<T> a;
  public:
  fenwick(int n):n(n),a(n+1,0){}
  T getsum(int ix){ T ret=0; for(int i=ix;i>0;i-=(i&(-i)))ret+=a[i]; return ret; }
  T getsumbw(int ia, int ib){ return(getsum(ib)-getsum(ia-1)); }
  void add(int ix, T val) { for(int i=ix;i<=n;i+=(i&(-i)))a[i]+=val; }
  T getval(int ix){
    T ret = a[ix];
    if(ix>0) {
      int tmp = ix - (ix&(-ix));
      ix--;
      while(ix!=tmp){ ret -= a[ix]; ix -= (ix&(-ix));
      }
    }
    return ret;
  }
};
endsnippet

snippet fenwickmax "range max using fenwick"
template <typename T>
class fenwick {
  int n;vector<T> a; vecto<T> v;
  public:
  fenwick(int n):n(n),a(n+1),v(n+1){}
  void set(int ix, T val) { if(v[ix]<val) {v[ix]=val;for(int i=ix;i<=n;i+=(i&(-i)))a[i]=max(a[i],val);}}
  T getmax(int ix){ $1 ret=0; for(int i=ix;i>0;i-=(i&(-i)))ret=max(ret,a[i]); return ret; }
  T getrangemax(int ia, int ib){
    if(ia==ib)return v[ia];
    int ix=ib-(ib&(-ib));
    if(ix>=ia)return max(a[ib],getrangemax(ia,ix));
    else return max(v[ib],getrangemax(ia,ib-1));
  }
  T getval(int ix){return v[ix];}
};
endsnippet

snippet trie "form a tree using array of words"
class trie {
  int ix, tx;
  vector<vi> t;
  vi endix;
  public:
    trie():
      ix(0),tx(1),t(MAXT,vi(26,0)),endix(MAXT,-1){}
    void update(const char* s, int tix=0){
      if((*s)==0){
        endix[tix]=ix;
        return;
      }
      int c=(*s)-'a';
      if(t[tix][c]==0)t[tix][c]=tx++;
      update(s+1,t[tix][c]);
    }
    void addword(const char* s){
      update(s);
      ix++;
    }
};
endsnippet

snippet policy "policy based structure"
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
endsnippet
