snippet cnk2 "select k from n"
ll cnk(int n, int k){
  if(n<k)return 0;
  ll ret=1;
  for(ll i=1;i<=k;i++){ ret = ret*(n-i+1)/i; }
  return ret;
}
endsnippet

snippet gcd "gcd of two numbers"
${1:int} gcd($1 a, $1 b){
  if(b==0)return a;
  return gcd(b,a%b);
}
endsnippet

snippet lcm "lcm of two numbers"
${1:int} lcm($1 a, $1 b){
  $1 g=gcd(a,b);
  return (a/g)*b;
}
endsnippet

snippet power "a to the power of b"
int power(int a, int b) {
  int res = 1;
  while (b > 0) {
    if (b & 1) { mulmod(res, a); }
    b >>= 1;
    mulmod(a, a);
  }
  return res;
}
endsnippet

snippet inversemod "inverse mod of a number"
int inv(int a) { return power(a, MODV - 2); }
endsnippet

snippet fact "calculate factorials"
vi fact, invfact;
void calcfact(){
  static bool done=false;
  if(done)return;
  done=true;
  fact.resize(MAXN);
  invfact.resize(MAXN);
  fact[0]=invfact[0]=1;
  for(int i=1;i<MAXN;i++){
    fact[i]=fact[i-1];
    invfact[i]=invfact[i-1];
    mulmod(fact[i],i);
    mulmod(invfact[i],inv(i));
  }
}
endsnippet

snippet cnk "calculate cnk using mod"
int cnp(int n, int k){
  static bool done=false;
  if(!done){ done=true; calcfact(); }
  int res=fact[n];
  mulmod(res,invfact[k]);
  mulmod(res,invfact[n-k]);
  return res;
}
endsnippet

snippet matrix-ops "matrix operations"
void roll(char &a, char &b, char &c, char &d){
  int temp=a;
  a=b; b=c; c=d; d=temp;
}
template <typename T>
T rotate(T inp, int n){
  T b=a;
  for(int i=0;i<n/2; i++)
  for(int j=0;j<(n+1)/2;j++){
    roll(b[i][j],b[n-1-j][i],b[n-1-i][n-1-j],b[j][n-1-i]);

  }
  return b;
}
template <typename T>
T reflect(T a, int n){
  T b=a;
  for(int i=0;i<n;i++){
    for(int j=0;j<n/2;j++)swap(b[i][j],b[i][n-1-j]);
  }
  return b;
}
endsnippet

snippet sieve "generate and find prime"
bool prime[MAXN];
vi pn;
void sieve(){
  memset(prime,true,sizeof(prime));
  pn.clear();
  prime[0]=prime[1]=false;
  for(int i=2;i*i<=MAXN;i++)
  if(prime[i]){
    for(int j=i*i;j<MAXN;j+=i)prime[j]=false;
  }
  for(int i=2;i<MAXN;i++){
    if(prime[i])pn.pb(i);
  }
}
bool isprime(ll n){
  if(n<MAXN)return prime[n];
  for(size_t i=0;i<pn.size() && (ll)pn[i]*pn[i]<=n;i++){
    if(n%pn[i]==0)return false;
  }
  return true;
}
endsnippet
snippet matrix "matrix multiplication and exp"
class mat{
  typedef ${1:int} T;
  typedef vector<vector<T>> M;
  typedef vector<T> V;
  public:
  int r, c;
  M m;
  mat(const int &r, const int &c):r(r),c(c),m(r,V(c,0)){}
  mat mul(const mat &other){
    assert(c==other.r);
    int rr=r, rc=other.c;
    mat res(rr,rc);
    for(int i=0;i<rr;i++)for(int j=0;j<rc;j++)
    for(int k=0;k<c;k++)res.m[i][j]+=m[i][k]*other.m[k][j];
    return res;
  }
  void pow(${2:int} b){
    assert(r==c);
    mat res(r,c);
    for(int i=0;i<r;i++)res.m[i][i]=1;
    while(b){
      if(b&1)res=res.mul(*this);
      *this=mul(*this);
      b/=2;
    }
    m=move(res.m);
  }
};
endsnippet
