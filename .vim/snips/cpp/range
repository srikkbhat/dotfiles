snippet rangetree "range queries"
template <typename T>
class bitree{ //range max between two ix
  const int n; const T *a; //inp array ix 0->n-1
  T *t; //b tree
  public:
  bitree(const T& a, const int &n){
    this->n=n; this->a = &a; t = new T[4*n]();
  }
  ~bitree(){ delete[] t; }
  void build(int v=1, int l=0, int r=n-1){
    if(l==r){ t[v] = a[l]; return; }
    int mid = (l+r)/2, nv=v*2;
    build(nv, l, mid); build(nv+1, mid+1, r);
    t[v] = max(t[nv], t[nv+1]);
  }
  void update(int ix, int v=1, int l=0, int r=n-1){
    if(l==r){ t[v]=a[ix]; return; }
    int mid = (l+r)/2, nv=v*2;
    if(ix<=mid) update(ix,nv,l,mid);
    else update(ix,nv+1,mid+1,r);
    t[v]=max(t[nv], t[nv+1]);
  }
  T query(int ql,int qr,int v=1,int L=0,int R=n-1){ //ql, qr inclusive
    if(ql>R || qr<L)return 0;
    if(ql<=L && qr>=R)return t[v];
    int MID = (L+R)/2, nv=v*2;
    T ans = max(query(ql,qr,nv,L,MID), query(ql,qr,nv+1,MID+1,R));
    return ans;
  }
};
endsnippet

snippet rangesum "sum of array ranges"
class rangesum{
  ${1:ll} * sum;
  public:
    rangesum(const ${2:int} *inp, const int &n){ //ix 0->n-1
      sum=new $1[n+1]();
      for(int i=0;i<n;i++) s[i+1]=s[i]+inp[i];
    }
    ~rangesum() {delete [] sum;}
    $1 get(int x, int y) {return s[y+1]-s[x];} //y>=x, x,y inclusive

}
endsnippet
snippet sliding "sliding min / max"
class slidingmin {
  int l, r, n;
  const ${1:int} *a;
  typedef pair<$1,int> spi;
  deque<spi> dq;
  public:
  slidingmin(const $1 *a, int n):n(n),l(-1),r(-1),a(a){}
  $1 slide(int L, int R){ //0->n-1
    assert(l<=L && r<=R && L<n && R<n);
    for(int i=r+1;i<=R;i++){
      while(!dq.empty() && dq.back().fi>=a[i])dq.pop_back();
      dq.push_back(spi(a[i],i));
    }
    while(dq.front().se<L)dq.pop_front();
    l=L,r=R;
    return dq.front().fi;
  }
};
endsnippet
